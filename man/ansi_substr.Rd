% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/substring.R
\name{ansi_substr}
\alias{ansi_substr}
\alias{ansi_substring}
\title{Substring of an ANSI-styled string, keeping correct colors}
\usage{
ansi_substr(x, start, stop)

ansi_substring(text, first, last = 1000000L)
}
\arguments{
\item{x, text}{A character vector.}

\item{start, first}{Integer, the first element to be extracted.}

\item{stop, last}{Integer, the last element to extracted.}
}
\value{
For \code{substr}, a character vector of the same length and with
the same attributes as \code{x} (after possible coercion).

For \code{substring}, a character vector of length the longest of the
arguments.  This will have names taken from \code{x} (if it has any
after coercion, repeated as needed), and other attributes copied
from \code{x} if it is the longest of the arguments).
}
\description{
These functions are the ANSI-aware counterparts of \code{\link[base:substr]{base::substr()}} and
\code{\link[base:substring]{base::substring()}}. They extract substrings from a character vector,
while keeping the colors and style of the characters in the strings
the same.
}
\examples{
str <- crayon::bold(
  "This text is bold, and", crayon::red("parts of it are red,"),
  "parts of it not."
)
cat(str, "\\n")

cat(ansi_substr(str, 1, 17), "\\n")
cat(ansi_substr(str, 1, 42), "\\n")
cat(ansi_substr(str, 24, 42), "\\n")

## Vector arguments, just like in base::substring and base::substr
cat(ansi_substr(c(str, str), c(1, 20), c(22, 42)), sep = "\\n")
cat(ansi_substring(str, 1:30, 1:30), "\\n")
}
